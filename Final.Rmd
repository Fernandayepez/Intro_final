---
title: "Final"
output:
  pdf_document: default

---

step 1-get all the possible d\^2 with our data and distribute it

```{r}
library(gtools)
library(MASS)

df1 <- read.csv("Body_masses.csv")

df1$Body.mass <- log(df1$Body.mass)

results_df <- data.frame()

num_permutations <- 2000

for (i in 1:num_permutations) {
  
  perms <- sample(df1$Body.mass, length(df1$Body.mass), replace = FALSE)
  
  results_df <- rbind(results_df, data.frame(Permutation = i, Body.mass = perms))
}


calculate_sum_squared_differences <- function(vector) {
  squared_differences <- (vector[-1] - vector[-length(vector)])^2
  sum_squared_differences <- sum(squared_differences)
  mean_value <- mean(vector)
  differences <- vector - mean_value
  sum_of_differences <- sum((differences)^{2})
  c_value <- sum_squared_differences / sum_of_differences
  return(c_value)
}

c_value_df <- data.frame(Result = numeric(0))

for (i in 1:num_permutations) {
  perm_values <- results_df$Body.mass[results_df$Permutation == i]
  result <- calculate_sum_squared_differences(perm_values)
  c_value_df <- rbind(c_value_df, data.frame(Result = result))
}


# fitting a normal distribution to my results
fit <- fitdistr(c_value_df$Result, densfun = "normal")
mean_estimate <- fit$estimate["mean"]
sd_estimate <- fit$estimate["sd"]

# I thought it was normal now 
hist(c_value_df$Result, main = "Histogram of C Values", xlab = "C Values", ylab = "Frequency", col = "lightblue", border = "black")



```

intermediate step to see that this works correctly 

```{r}
library(ape)
library(igraph)
library(purrr)

# Begin by getting the edge matrix
original_tree <- read.tree(text = "((A, B),  (C,D));")
edges <- original_tree$edge


# function that gives us the adjacency matrix from our original edge 
create_adjacency_matrix <- function(edges) {
  # Find the number of nodes, to get the size of our matrix
  nodes <- unique(as.vector(edges))
  num_nodes <- length(nodes)

  # Create an empty adjacency matrix
  adj_matrix <- matrix(0, nrow = num_nodes, ncol = num_nodes)

  # Recursively populate 
  for (i in 1:nrow(edges)) {
    #we look at the edge matrix and the right column are the from_nodes
    from_node <- edges[i, 1]
    #left columns
    to_node <- edges[i, 2]

    if (from_node %in% nodes) {
  #storing the first to_node as the right child, defined as 1
      adj_matrix[from_node, to_node] <- 1 
  #we remove from_node from the list
      nodes <- nodes[nodes != from_node]
    } else {
  #if it appears again then we assign the remaining child to the left, defined as 2
      adj_matrix[from_node, to_node] <- 2  
    }
  }

  return(adj_matrix)
}

case_matrix <-create_adjacency_matrix(edges)
print(case_matrix)

#finds children of a specific node in the adj matrix
find_children <- function(adj_matrix, node) {
  children_right <- which(adj_matrix[node,] == 1)  # Right child
  children_left <- which(adj_matrix[node,] == 2)  # Left child

  #no children
  if (identical(children_right, integer(0))) {
    result <- list(right = -1, left = -1)
  } else {
    result <- list(right = children_right, left = children_left)
  }
  

  return(result)
}

#find_flips <- function(adj_matrix) {
 # num_rows <- nrow(adj_matrix)
 # flips_list <- vector("list", length = num_rows)

  #for (i in 1:num_rows) {
   # row <- adj_matrix[i, ]
    #flips <- which(row == 2)
    #flips_list[[i]] <- flips
  #}

  #return(flips_list)
#}

# Test the function with your case_matrix
#flips_result <- find_flips(case_matrix)
#print(flips_result)

all_combinations <- function(adj_matrix, num) {

#get the children

 results <- find_children(adj_matrix, num)

#define

 left_child <- results$left
 right_child <- results$right

#this is the end 

  if (left_child == -1) {

    copy_adj_matrix <- adj_matrix

    return(copy_adj_matrix)

  } else {

#make a copy for each recursion so you have a copy for every flip

    left_1_copy_adj_matrix <- adj_matrix

#calling function with nothing flipped, asking to flip children of left child

    left_1 <- all_combinations(left_1_copy_adj_matrix, left_child)
    
# flip children of right child

    right_1_copy_adj_matrix <- adj_matrix

    right_1 <- all_combinations(right_1_copy_adj_matrix, right_child)
    
    
# Swap left  and right children
    adj_matrix[num, left_child] <- 1
    adj_matrix[num, right_child] <- 2
 
   
#calling function with nothing flipped, asking to flip children of left child (used to be right child)
    left_2_copy_adj_matrix <- adj_matrix
    left_2 <- all_combinations(left_2_copy_adj_matrix, left_child)
   

   #calling function with nothing flipped, asking to flip children of right child (used to be left child)
    right_2_copy_adj_matrix <- adj_matrix
    right_2 <- all_combinations(right_2_copy_adj_matrix, right_child)
    
    return(list(left_1, left_2, right_1, right_2))
    
  }
}
    
adjoint_list <-all_combinations(case_matrix,5)
print(adjoint_list)


#call function
adj_matrix <- create_adjacency_matrix(edges)

# we 4 sets of matrices
result <- all_combinations(adj_matrix, 5)


# Function to get the last matrix in each sublist (maybe a partial solution?)
get_last_matrix <- function(lst) {
  lapply(lst, function(x) {
    if (is.list(x)) {
      get_last_matrix(head(x, n = 1))
      get_last_matrix(head(x, n = 2))
    } else {
      x
    }
  })
}

# Apply the function 
unique_matrices <- get_last_matrix(result)

```

```{r}

get_edge_matrix <- function(adj_matrix) {
  num_nodes <- nrow(adj_matrix)
  edge_matrix <- matrix(NA, ncol = 2, nrow = 0)

  # We define what a child would look like in the adj matrix
  find_children <- function(parent, root) {
    children <- which(adj_matrix[parent, ] != 0)
    right_children <- children[adj_matrix[parent, children] == 1]
    left_children <- children[adj_matrix[parent, children] == 2]

    # We add the right children
    for (child in right_children) {
      edge <- c(parent, child)
      edge_matrix <<- rbind(edge_matrix, edge)

      # Recursion
      find_children(child, root)
    }

    # Then, add left children
    for (child in left_children) {
      edge <- c(parent, child)
      edge_matrix <<- rbind(edge_matrix, edge)

      # Recursion
      find_children(child, root)
    }
  }

   #Iterate through nodes to find roots and start find
  for (node in 1:num_nodes) {
    if (sum(adj_matrix[, node] != 0) == 0) {
      # Node is a root
      find_children(node, node)
    }
  }

  return(edge_matrix)
}

# Example usage
adj_matrix <- matrix(c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0), nrow = 7, byrow = TRUE)

print(adj_matrix)

my_matrix <- get_edge_matrix(adj_matrix)

# Print the resulting matrix
print(my_matrix)


#print(unique_matrices)

#need to flatten it?
#edge_matrices_list <- lapply(unique_matrices, get_edge_matrix)
```

step 2-

```{r}

tree_string <- "((((((Odocoileus_hemionus,Odocoileus_virginianus),Rangifer_tarandus),Alces_alces),((Dama_dama,Cervus_canadensis))),Antilocapra_americana));"

tree <- read.tree(text = tree_string)

# I'm building the joint data outside of the csv file
tip_labels <- tree$tip.label
data_order <- c(Odocoileus_hemionus = 74, Odocoileus_virginianus = 57, Rangifer_tarandus = 100, Alces_alces = 384, Dama_dama = 55, Cervus_canadensis = 300, Antilocapra_americana = 50)

link_tree_values <- function(tree, tip_labels, data_order) {
  # Create a named vector with tip labels and corresponding values
  values_vec <- data_order[tip_labels]

  # Annotate the tree with values for tips
  tree$node.label <- ifelse(gsub(" ", "_", tree$tip.label) %in% names(values_vec), values_vec[gsub(" ", "_", tree$tip.label)], NA)

  return(tree)

}

tree_with_values <- link_tree_values(tree, tip_labels, data_order)
print(tree_with_values)

edges <-tree_with_values$edge

# function that gives us the adjacency matrix from our original edge 
create_adjacency_matrix <- function(edges) {
  # Find the number of nodes, to get the size of our matrix
  nodes <- unique(as.vector(edges))
  num_nodes <- length(nodes)

  # Create an empty adjacency matrix
  adj_matrix <- matrix(0, nrow = num_nodes, ncol = num_nodes)

  # Recursively populate 
  for (i in 1:nrow(edges)) {
    #we look at the edge matrix and the right column are the from_nodes
    from_node <- edges[i, 1]
    #left columns
    to_node <- edges[i, 2]

    if (from_node %in% nodes) {
  #storing the first to_node as the right child, defined as 1
      adj_matrix[from_node, to_node] <- 1 
  #we remove from_node from the list
      nodes <- nodes[nodes != from_node]
    } else {
  #if it appears again then we assign the remaining child to the left, defined as 2
      adj_matrix[from_node, to_node] <- 2  
    }
  }

  return(adj_matrix)
}

#We wish to find all combinations 
all_combinations <- function(adj_matrix, num) {
 #we have a function to find children later
 results <- find_children(adj_matrix, num)
 left_child <- results$left
 right_child <- results$right
 
 

 #first we take the case that there are no kids, if none then we just return a copy of what we have
  if (left_child == -1) {
    copy_adj_matrix <- adj_matrix
    return(copy_adj_matrix)
  } else {
    # Recursively taking the combinations of the left tree
    left_1_copy_adj_matrix <- adj_matrix
    left_1 <- all_combinations(left_1_copy_adj_matrix, left_child)
    
    # Recursively taking the combinations of the right tree
    right_1_copy_adj_matrix <- adj_matrix
    right_1 <- all_combinations(right_1_copy_adj_matrix, right_child)
    
    
    # Swap left and right
    adj_matrix[num, left_child] <- 1
    adj_matrix[num, right_child] <- 2
    print(adj_matrix)
    
    #now switching the placement of the left tree with the right tree
    left_2_copy_adj_matrix <- adj_matrix
    left_2 <- all_combinations(left_2_copy_adj_matrix, right_child)
    
    # Swap left and right
    adj_matrix[num, left_child] <- 1
    adj_matrix[num, right_child] <- 2 
    #now switching the placement of the left right with the left tree
    right_2_copy_adj_matrix <- adj_matrix
    right_2 <- all_combinations(right_2_copy_adj_matrix, left_child)
    
    return(list(left_1, left_2, right_1, right_2))
    
  }
}

find_children <- function(adj_matrix, node) {
  children_right <- which(adj_matrix[node,] == 1)  # Right child
  children_left <- which(adj_matrix[node,] == 2)  # Left child

  
  if (identical(children_right, integer(0))) {
    result <- list(right = -1, left = -1)
  } else {
    result <- list(right = children_right, left = children_left)
  }
  

  return(result)
}


adj_matrix <- create_adjacency_matrix(edges)
print(adj_matrix)
result <- all_combinations(adj_matrix, 8)

# Function to get the last matrix in each sublist
get_last_matrix <- function(lst) {
  lapply(lst, function(x) {
    if (is.list(x)) {
      get_last_matrix(head(x, n = 1))
      get_last_matrix(head(x, n = 2))
    } else {
      x
    }
  })
}
# Apply the function to your list
unique_matrices <- get_last_matrix(result)

get_edge_matrix <- function(adj_matrix) {
  num_nodes <- nrow(adj_matrix)
  edge_matrix <- matrix(NA, ncol = 2, nrow = 0)

  # We define what a child would look like in the adj matrix
  find_children <- function(parent, root) {
    children <- which(adj_matrix[parent, ] != 0)
    right_children <- children[adj_matrix[parent, children] == 1]
    left_children <- children[adj_matrix[parent, children] == 2]

    # We add the right children
    for (child in right_children) {
      edge <- c(parent, child)
      edge_matrix <<- rbind(edge_matrix, edge)

      # Recursion
      find_children(child, root)
    }

    # Then, add left children
    for (child in left_children) {
      edge <- c(parent, child)
      edge_matrix <<- rbind(edge_matrix, edge)

      # Recursion
      find_children(child, root)
    }
  }

   #Iterate through nodes to find roots and start find
  for (node in 1:num_nodes) {
    if (sum(adj_matrix[, node] != 0) == 0) {
      # Node is a root
      find_children(node, node)
    }
  }

  return(edge_matrix)
}

print(unique_matrices)

```


```{r}
library(ape)
library(phangorn)
library(gtools)

tree_string <- "((((((Odocoileus_hemionus,Odocoileus_virginianus),Rangifer_tarandus),Alces_alces),((Dama_dama,Cervus_canadensis))),Antilocapra_americana));"

tree <- read.tree(text = tree_string)

tree$edge
# I'm building the joint data outside of the csv file
tip_labels <- tree$tip.label
data_order <- c(Odocoileus_hemionus = 74, Odocoileus_virginianus = 57, Rangifer_tarandus = 100, Alces_alces = 384, Dama_dama = 55, Cervus_canadensis = 300, Antilocapra_americana = 50)

link_tree_values <- function(tree, tip_labels, data_order) {
  # Create a named vector with tip labels and corresponding values
  values_vec <- data_order[tip_labels]

  # Annotate the tree with values for tips
  tree$node.label <- ifelse(gsub(" ", "_", tree$tip.label) %in% names(values_vec), values_vec[gsub(" ", "_", tree$tip.label)], NA)

  return(tree)

}

tree_with_values <- link_tree_values(tree, tip_labels, data_order)
print(tree_with_values)


# adapted function from above 
calculate_c_value <- function(data_vector) {
  squared_differences <- (data_vector[-1] - data_vector[-length(data_vector)])^2
  sum_squared_differences <- sum(squared_differences)
  mean_value <- mean(data_vector)
  differences <- data_vector - mean_value
  sum_of_differences <- sum(differences^2)
  c_value <- sum_squared_differences / sum_of_differences
  return(c_value)
}


# getting all the c values 
#c_values <- sapply(data_vectors_list, calculate_c_value)

#average_c_value <- mean(c_values)

```

```{r}
 m <- matrix(c(5, 6, 6, 1,6, 2, 5, 7, 7, 3, 7, 4), nrow = 6, byrow = TRUE)

print(m)
```

